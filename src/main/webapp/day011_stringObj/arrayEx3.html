<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>
	<script>
	//join() : 배열을 주어진 특정 문자로 분리해서 문자열로 리턴하는 메소드.
		myJo=["김도연","김재형","이재흥","박찬우","허지윤"];
		typeof(myJo.join()); // typeof : ()안의 object 의 속성을 알려줌(string 인지)
		console.log(myJo.join("/")); // 배열을 "/" 을 추가하여 문자열로 리턴.
		console.log(myJo.pop()); // 마지막 요소 출력.
		console.log(myJo); // pop으로 인해 마지막 요소 삭제.
		
		yourJo=["주영","아영"];
	
	//concat() 은 호출하는 배열의 값과 파라미터로 오는 배열을 합쳐서 새로운 배열을 리턴하는 메소드.
		const newArr = myJo.concat(yourJo);
		console.log(newArr);
		console.log(newArr.indexOf("박찬우"));
		
	//includes(value) : 배열내에 value 가 존재한다면 true 아니면 false 리턴.
		console.log(newArr.includes("박찬우"));
	
	//find(callbackFN) : 콜백 함수에서 정의된 기준의 값이 존재하는지를 알아봄. 만약 존재하면 해당 값을 리턴시키거나 값을 연산을 처리할 수 있음.
		const scores=[20,40,67,33,40,5,79,100];
		//위 scores 에서 점수가 70점 이하인 값만 추출 하고 싶습니다. 이때 filter()를 사용함.]
		
		console.log(scores.find(value =>  value >= 90));
		console.log(scores.findIndex(value =>  value >= 90));
		
	//정렬(sort) 를 지원하는 메소드의 종류로는 sort(), reverse(), min(), max(), filter() ...etc
	//sort: 맨 앞글자 기준, 순서대로(배열은 오름차순, 문자열은 가나다 or alphabet 순.)정렬.
		console.log(typeof(scores.sort()));
	
		//정렬의 기준을 잡을 때, 기준 콜백을 주게 되면 그대로 정렬됨. 정렬 기준은 오름차순(1-10) 인경우엔 a-b로. 반대의 경우엔 b-a를 리턴해주면 됨.
		console.log(scores.sort((a,b)=>{return a-b}));
		//오름차순(ascending), 내림차순(Descending)
		console.log(scores.sort((a,b)=>b-a));
		//랜덤정렬
		/* console.log(scores.sort((a,b)=>0.5-Math.random())); */
		/* 배열의 가장 최솟값과 최댓값은 아래의 로직을 통해 얻어낼 수 있음.
			찾아내는 함수를 하나 정의하고 Math.min.apply()를 통해 최소, 최대를 식별함.
			만약 최댓값을 찾으려면 Math.max.apply(null,배열)을 이용하면 됨. */
		function findMin(arr){
			return Math.min.apply(null,arr);
		}
		console.log(scores.indexOf(findMin(scores)));
	//map(callback) : 콜백을 통해 배열에 연산을 할 수 있는 메소드. 원본배열은 건드리지 않음. 반드시 원본 배열의 값이 필요함.
		console.log(scores.map(value => value*2));
		console.log(scores);
		
	//filter(callback): 콜백을 통해 특정 조건 이상인 원본 배열의 값을 복사해서 새로운 배열을 리턴시킴. 원본 불변 메소드임.
		console.log(scores.filter(val => val>50));
	
	/* Map은 Collection의 일종으로 값을 key로 매핑애서 관리함. 
		key가 매우 중요한 요소인데, 배열을 이용할때 따로 키를 생성하지 않아도 key를 리턴하도록 만들어서
		위의 map의 key로서 사용가능. 아래는 그 형식임. */
		let keys = scores.keys();
		for(let x of keys){
			console.log(x);
		}
		
	//spread() : 배열 복제 메소드임. 사용방식은 다음과 같음.
	//...or... 배열명 : 차이점 ...배열명 모두 복사. 두개의 배열의 고유속성을 유지한 채로 합침.
		const sp1=[...newArr,...scores];
		console.log(sp1);
	</script>
</body>
</html>